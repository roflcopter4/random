#!/usr/bin/env python3

import sys
import getopt
from random import shuffle

FILENAME = "shuffledDeck.txt"

###############################################################################
# Classes


class Deck:
    """This mini-class exists mostly to varify the validity of a given deck and
    distribute the cards therein between players.
    """

    # Evil literals indicating legal card values.
    Field1 = ['A', 'K', 'Q', 'J', '0', '2', '3', '4', '5', '6', '7', '8', '9']
    Field2 = ['C', 'D', 'H', 'S']
    # Evil literal dict to convert Ace, King, Queen, Jack, and 10 to integers.
    CardVals = {
        'A': 14,
        'K': 13,
        'Q': 12,
        'J': 11,
        '0': 10
    }
    EXIT_VAL = 2

    def __init__(self, deck):
        self.deck = deck
        # Initial sanity check
        try:
            self.analyze_deck()
        except AssertionError as err:
            self.__handle_deck_error(err)

    def __handle_deck_error(self, err):
        """Prints error message generated by self.analyze_deck() and exits."""
        print("ERROR:   Deck sanity check failed. Aborting.", file=sys.stderr)
        print("Reason: ", err, file=sys.stderr)
        sys.exit(self.EXIT_VAL)

    def analyze_deck(self, deck=None):
        """Checks a given 'deck' list for validity. If this is an instance of
        the Deck class this method can analyze its 'deck' attribute, or it can
        take one as a paramater. If the deck is not valid an angry warning will
        be displayed and the program euthenized. Specifically the deck list is
        required to contain:
            1) exactly 52 members (cards), all of which must be unique,
            2) only valid, correctly formatted playing cards (ie strings
               exactly of exactly 2 chars), and
            3) all of the required cards in a traditional paying card deck
               (excluding jokers).
        """
        deck = self.deck if deck is None else deck
        assert len(deck) == 52, "Deck is the wrong size."
        assert len(set(deck)) == 52, "Deck contains non-unique cards."
        assert len(''.join(deck)) == (52 * 2), \
            "All 'cards' in the deck must be exactly two characters long."

        # So there are 52 unique strings of size 2. Because they're unique the
        # only way they'll all match is if we have every required card.
        # A regex like /([AKQJ02-9][CDHS]){52}/ could do away with the loop...
        for card in deck:
            assert (card[0] in self.Field1) and (card[1] in self.Field2), \
                "Invalid card: '%s'." % card

    def distribute(self, numplayers):
        hands = []
        for _ in range(numplayers):
            hands.append(Queue(52))

        shuffle(self.deck)
        player = 0
        for card in self.deck:
            hands[player].enqueue(card)
            player = (player + 1) % numplayers

        return hands

    def get_int_val(card):
        """Utility method for converting a card string to an integer that
        represents its value. Assumes correct input and returns an int between
        2 and 14. Card values are given as in the game of War.
        Does not take 'self' as a paramater.
        """
        if card[0] in Deck.CardVals.keys():
            cardval = Deck.CardVals[card[0]]
        else:
            cardval = int(card[0])

        return cardval


class Queue:
    """Simple implementation of a bounded circular queue."""

    def __init__(self, capacity):
        assert capacity >= 2, "Max capacity for a queue must be at least 2."
        self.__capacity = capacity
        self.__items = [None]*capacity
        self.__count = 0
        self.__head = 0
        self.__tail = 0

    def enqueue(self, item):
        """Places an item at the back of the queue."""
        assert self.__count < self.__capacity, "Queue is full!"
        self.__items[self.__tail] = item
        self.__tail = (self.__tail + 1) % self.__capacity
        self.__count += 1

    def dequeue(self):
        """Returns and removes the item at the front of the queue."""
        assert self.__count > 0, "Queue is empty!"
        item = self.__items[self.__head]
        self.__items[self.__head] = None
        self.__head = (self.__head + 1) % self.__capacity
        self.__count -= 1
        return item

    def peek(self):
        """Returns the item at the front of the queue without removing it, or
        None if the the queue is empty (ie no exception is raised).
        """
        if self.__count > 0:
            return self.__items[self.__head]
        else:
            return None

    def get_size(self):
        return self.__count

    def is_full(self):
        return self.__count == (self.__capacity - 1)

    def is_empty(self):
        return self.__count == 0

    def clear(self):
        self.__items = [None for _ in range(self.__capacity)]
        self.__count = self.__head = self.__tail = 0

    def debug_get_items(self):
        """Returns the full item list as a python list. FOR DEBUGGING ONLY."""
        return self.__items

    def pdiagnostics(self):
        s = self  # Sleezy way to make the print fit into two lines < 79 chars.
        print("%s, H=%d, T=%d, (%d/%d)" %
              (str(s.__items), s.__head, s.__tail, s.__count, s.__capacity))


class Hand(Queue):

    def __init__(self, cards, war_type, player_number):
        super().__init__(self, 52)

        self.__war_type = int(war_type)
        self.__player_number = player_number
        for card in cards:
            self.enqueue(card)

    def get_card(self):
        assert not self.__is_empty, self.__player_number
        self.dequeue()

    def get_war_cards(self):
        return [self.get_card() for _ in range(self.war_type)]

    def add_cards(self, lst):
        for card in lst:
            self.enqueue(card)


class OnTable:

    # Multipliers used to in the __get_index method to return a negative value
    # for player 2 (index 1) and a positive one for player 1 (index 0). This
    # could also have been a dictionary, or even just represented as a literal
    # in the method itself. I don't know which is best practice.
    __multiplier = [1, -1]

    def __init__(self):
        self.__count = [0, 0]
        self.__cards = [None]*52
        self.__faceUp = [None]*52

    def place(self, player, card, isHidden):
        p_ind = player - 1
        index = self.__get_index(p_ind)

        self.__count[p_ind] += 1
        self.__cards[index] = card
        self.__faceUp[index] = isHidden

    #
    # Player 1 (ie index 0) places cards at the start of the list and player 2
    # (index 1) places them at the end. Because of this we can use a positive
    # and negative index respectively. Lists start at index 0, so we must also
    # subtract 1 from the second player's index to get the proper spot. Since
    # we know there will only be two players we can just subtract the value of
    # the player index itself (0 or 1) to accomplish this.
    #
    def __get_index(self, p_ind):
        """Returns the index in the two lists into which the next card and
        boolean value will be placed. Player 1 uses a positive index and player
        2 a negative one.
        """
        return (self.__multiplier[p_ind] * self.__count[p_ind]) - p_ind

    #
    def clear(self):
        lst = []
        for card in self.__cards:
            if card is not None:
                lst.append(card)
        self.__count = [0, 0]
        self.__cards = [None]*52
        self.__faceUp = [None]*52

        return lst

    def __str__(self, player=None):
        if player is None or player in (1, 2):
            return self.__do__str__()
        elif player == 'both':
            return self.__do__str__(1), self.__do__str__(2)

    def __do__str__(self, player=None):
        if player is None:
            Range = range(52)
        else:
            p_ind = player - 1
            index = self.__get_index(p_ind)
            Range = range((0 - p_ind), index, self.__multiplier[p_ind])
        buf = '['
        for i in Range:
            card = self.__cards[i]
            if card is not None:
                buf += card if self.__faceUp[i] else "XX"
                buf += ", "

        return buf[:-2] + ']'


###############################################################################
# Functions


def main(infile=None):
    deck_t = Deck(process_file(infile))

    again = True
    while again:
        hands = [None, *deck_t.distribute(2)]
        table = OnTable()

        # gametype_prompt = "Would you like to play 1, 2, or 3 card war?  "
        # numcards = input(gametype_prompt)
        # while numcards not in ('1', '2', '3'):
        #     print("Invalid input.")
        #     numcards = input(gametype_prompt)
        game_type = 2

        try:
            play(game_type, hands, table)
        except AssertionError as err:
            print("GAME OVER!\nPlayer %s wins!" % err)

        if input("\nPlay again? y/n  ") not in ('y', 'Y', 'yes'):
            again = False


def play(game_type, player_hands, table):
    c2int = Deck.get_int_val
    gameover = False
    hand_1 = player_hands[1]
    hand_2 = player_hands[2]

    while not gameover:
        faceup_1 = hand_1.get_card()
        table.place(1, faceup_1, True)

        faceup_2 = hand_2.get_card()
        table.place(2, faceup_2, True)

        print("Player 1: %-2d cards." % (hand_1.get_size()+1))
        print("Player 2: %-2d cards." % (hand_2.get_size()+1))
        print("CARDS ON TABLE")
        # print("From player 1:  %s\nFrom player 2:  %s" % table.__str__('both'))
        print(table.__str__())
        input()

        comp = FORTRAN_if(c2int(faceup_1), c2int(faceup_2))
        if comp == 1:
            hand_1.add_cards(table.clear())
        elif comp == -1:
            hand_2.add_cards(table.clear())
        else:
            for card in hand_1.get_war_cards():
                table.place(1, card, False)
            for card in hand_1.get_war_cards():
                table.place(1, card, False)


def process_file(infile=None):
    """Prompts the user for a filename (or optionally takes one as a
    paramater). If it is succesfully opened, the file is slurped into a list,
    stripped of newlines, converted to uppercase only, and returned. On
    failure, the user is prompted again for either another filename, or given
    the option to terminate the program.
    """
    lst = None
    if infile is None:
        if 'FILENAME' in globals():
            infile = FILENAME
        else:
            infile = input("Enter filename:  ")
    while lst is None:
        try:
            with open(infile, 'r') as fp:
                lst = [i.rstrip().upper() for i in fp]
        except FileNotFoundError:
            print("File '%s' not found." % infile)
            infile = input("Please type another filename or hit enter to " +
                           "quit.\n > ")
            if infile in ('', '\n', '\r\n'):
                sys.exit()

        except BaseException as err:
            print("Unexpected error:", err)
            sys.exit(1)

    return lst


def FORTRAN_if(val1, val2):
    """If val1 is less than val2, returns -1. If equal, returns 0. If val1 is
    larger, returns 1. Just like that one programming language's old if.
    """
    if val1 > val2:
        return 1
    elif val1 == val2:
        return 0
    else:
        return -1


###############################################################################
# Init


def get_options():
    kwargs = {}
    options = ['hf:', ['help', 'file=']]
    try:
        opts, args = getopt.getopt(sys.argv[1:], *options)
    except getopt.GetoptError as err:
        print(err)
        ShowUsage()
    else:
        for opt, optarg in opts:
            opt = opt.lstrip('-')
            if opt in ('h', "help"):
                ShowUsage(options)
            elif opt in ('f', "file"):
                kwargs['infile'] = str(optarg)
        return kwargs


def ShowUsage(options):
    print("""Usage: %s -[%s] --[%s]"""
          % (sys.argv[0], options[0], ', '.join(options[1])))
    sys.exit()


if __name__ == "__main__":
    main(**get_options())

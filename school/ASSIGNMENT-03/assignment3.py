#!/usr/bin/env python3

import sys
import getopt
from subprocess import call as syscall
import random

if sys.platform == "win32":
    CLEAR = "cls"
else:
    CLEAR = "clear"

###############################################################################
# Classes


class OutOfCards(Exception):
    """Player has run out of cards."""


class Deck:
    """This mini-class exists mostly to varify the validity of a given deck and
    distribute the cards therein between players.
    """
    # Evil literals indicating legal card values.
    Field1 = ['A', 'K', 'Q', 'J', '0', '2', '3', '4', '5', '6', '7', '8', '9']
    Field2 = ['C', 'D', 'H', 'S']

    # Hash to convert Ace, King, Queen, Jack, and '0' (10) to integers.
    CardVals = {
        'A': 14,
        'K': 13,
        'Q': 12,
        'J': 11,
        '0': 10
    }

    def __init__(self, deck):
        self.deck = deck
        try:  # Initial sanity check
            self.__analyze_deck()
        except AssertionError as e:
            self.__handle_deck_error(e)

    def __handle_deck_error(self, e):
        """Prints error message generated by self.analyze_deck() and exits."""
        print("ERROR:   Deck sanity check failed. Aborting.", file=sys.stderr)
        print("Reason: ", e, file=sys.stderr)
        sys.exit(1)

    def __analyze_deck(self):
        """Checks a given 'deck' list for validity. If invalid the program
        dies. Specifically the deck list is required to contain:
            1) exactly 52 members (cards), all of which must be unique,
            2) only valid, correctly formatted playing cards (ie strings
               exactly of exactly 2 chars), and
            3) all of the required cards in a traditional paying card deck
               (excluding jokers).
        """
        assert len(self.deck) == 52, "Deck is the wrong size."
        assert len(set(self.deck)) == 52, "Deck contains non-unique cards."
        assert len(''.join(self.deck)) == (52 * 2), \
            "All 'cards' in the deck must be exactly two characters long."

        # So there are 52 unique strings of size 2. Because they're unique the
        # only way they'll all match is if we have every required card.
        for card in self.deck:
            assert (card[0] in self.Field1) and (card[1] in self.Field2), \
                "Invalid card: '%s'." % card

    def distribute(self, numplayers):

        hands = [[] for _ in range(numplayers)]

        random.shuffle(self.deck)
        player = random.randint(0, 1)
        print(player)
        for card in self.deck:
            # hands[player].enqueue(card)
            hands[player].append(card)
            player = (player + 1) % numplayers

        return hands


# ============================================================================


class Queue:
    """Simple implementation of a bounded circular queue."""

    def __init__(self, capacity):
        assert capacity >= 2, "Max capacity for a queue must be at least 2."
        self.__capacity = capacity
        self.__items = [None]*capacity
        self.__count = 0
        self.__head = 0
        self.__tail = 0

    def enqueue(self, item):
        """Places an item at the back of the queue."""
        assert self.__count < self.__capacity, "Queue is full!"
        self.__items[self.__tail] = item
        self.__tail = (self.__tail + 1) % self.__capacity
        self.__count += 1

    def dequeue(self):
        """Returns and removes the item at the front of the queue."""
        assert self.__count > 0, "Queue is empty!"
        item = self.__items[self.__head]
        self.__items[self.__head] = None
        self.__head = (self.__head + 1) % self.__capacity
        self.__count -= 1
        return item

    def peek(self):
        """Returns the item at the front of the queue without removing it, or
        None if the the queue is empty (ie no exception is raised).
        """
        if self.__count > 0:
            return self.__items[self.__head]
        else:
            return None

    def get_size(self):
        """Returns current size of the queue."""
        return self.__count

    def is_full(self):
        """Returns whether the queue is full."""
        return self.__count == (self.__capacity - 1)

    def is_empty(self):
        """Returns whether the queue is empty."""
        return self.__count == 0

    def clear(self):
        """Empties the queue and resets everything."""
        self.__items = [None for _ in range(self.__capacity)]
        self.__count = self.__head = self.__tail = 0

    def debug_get_items(self):
        """Returns the full item list as a python list. FOR DEBUGGING ONLY."""
        return self.__items

    def pdiagnostics(self):
        s = self  # Sleezy way to make the print fit into two lines < 79 chars.
        print("%s, H=%d, T=%d, (%d/%d)" %
              (str(s.__items), s.__head, s.__tail, s.__count, s.__capacity))


# ============================================================================


class Hand(Queue):
    """Small extension of Queue with a few extra methods for convenience when
    representing a player's hand in the card game of War.
    """

    def __init__(self, cards, war_type):
        super().__init__(52)

        self.__war_type = int(war_type)
        for card in cards:
            self.enqueue(card)

    def get_card(self):
        """Differs from dequeue() in that this method returns None if the queue
        is empty, rather than crashing the program.
        """
        if self.is_empty():
            return None
        else:
            return self.dequeue()

    def get_war_cards(self):
        """Lazy way to get the required 1, 2, or 3 cards in a war scenario."""
        lst = [self.get_card() for _ in range(self.__war_type)]
        if None in lst:
            return None
        else:
            return lst

    def add_cards(self, lst):
        """Lazy way to queue up multiple cards after each turn."""
        for card in lst:
            self.enqueue(card)


# ============================================================================


class OnTable:
    """Representation of the cards currently on the table."""

    def __init__(self):
        self.__count = [0, 0]
        self.__cards = [None]*52
        self.__faceUp = [None]*52

    def __get_index(self, player):
        """Returns next free index in the two lists. Player 1 uses a positive
        index and player 2 a negative one.
        """
        if player == 1:
            return self.__count[player-1]
        elif player == 2:
            # We have to subtract 1 when counting backwards.
            return -(self.__count[player-1]) - 1
        else:
            # Pylint whines about inconsistent return statements without this.
            raise Exception

    def place(self, player, card, isHidden):
        """Stores a card in the internal list, along with the isHidden boolean
        to indicate whether the card is face up or down.
        """
        index = self.__get_index(player)

        self.__cards[index] = card
        self.__faceUp[index] = isHidden
        self.__count[player-1] += 1

    def clearTable(self):
        lst = []
        for card in self.__cards:
            if card is not None:
                lst.append(card)
        self.__count = [0, 0]
        self.__cards = [None]*52
        self.__faceUp = [None]*52

        return lst

    def __str__(self):
        buf = '['
        for i in range(52):
            card = self.__cards[i]
            if card is not None:
                buf += (card) if (self.__faceUp[i]) else ("XX")
                buf += ", "

        return buf[:-2] + ']'


###############################################################################
# Functions


def main(infile=None, numcards=None):
    deck_t = Deck(process_file(infile))
    again = True
    gametype_prompt = "Would you like to play 1, 2, or 3 card war?  "

    while again:
        if numcards is None:
            war_type = input(gametype_prompt)
            while war_type not in ('1', '2', '3'):
                print("Invalid input.")
                war_type = input(gametype_prompt)
        else:
            war_type = numcards

        hands = [None, *deck_t.distribute(2)]
        for player in (1, 2):
            hands[player] = Hand(hands[player], war_type)
        table = OnTable()
        syscall(CLEAR)

        play(hands, table)

        if input("\nPlay again? y/n  ") not in ('y', 'Y', 'yes'):
            again = False


def play(hands, table):
    faceup = [None]*3

    # The easiest way to break out of multiple levels of loops in python is
    # through exceptions. I hope this is not too far from the required algorithm.
    try:
        while True:
            for player in (1, 2):
                faceup[player] = hands[player].get_card()
                table.place(player, faceup[player], True)

            syscall(CLEAR)
            print_update(hands, table, faceup)
            comp = compare_cards(*faceup[1:])

            if comp == 0:
                print("Cards are equal - it's war!")
                for player in (1, 2):
                    cardlst = hands[player].get_war_cards()

                    # Because the player might be placing multiple cards down,
                    # it is possible to lose here, unlike earlier. The
                    # get_war_cards method will return None if the player did
                    # not have enough cards for war.
                    if None in cardlst:
                        raise OutOfCards(player)
                    for card in cardlst:
                        table.place(player, card, False)

                print("WARTIME TABLE UPDATE\n%s" % table)

            else:
                round_winner = 1 if (comp == 1) else 2
                hands[round_winner].add_cards(table.clearTable())
                print("Player %d wins this round." % round_winner)

                # Have to do this check after the fact because a win could save
                # a player who had 0 cards after placing one down.
                for player in (1, 2):
                    if hands[player].is_empty():
                        raise OutOfCards(player)

            input("\nPress enter to continue...")

    except OutOfCards as e:
        loser = int(e.args[0])
        winner = (loser + 1) % 2
        print("\nGAME OVER!\nPlayer %d is out of cards.\nPlayer %d wins!"
              % (loser, winner))


def print_update(hands, table, faceup):
    print("Player 1 just placed: %s" % faceup[1])
    print("Player 2 just placed: %s" % faceup[2])
    for player in (1, 2):
        print("Player %d cards remaining: %2d" %
              (player, hands[player].get_size()))
    print("\nALL CARDS ON TABLE (including above two)\n", str(table) + '\n')


# ============================================================================


def get_int_val(card):
    """Converts a string representing a card into an integer. Assumes correct
    input and returns an value between 2 and 14. Card values are given as in
    the game of War.
    """
    if card[0] in Deck.CardVals.keys():
        cardval = Deck.CardVals[card[0]]
    else:
        cardval = int(card[0])
    return cardval


def compare_cards(card1, card2):
    """Rather reminicient of Fortran's arithmetic if."""
    val1 = get_int_val(card1)
    val2 = get_int_val(card2)
    if val1 > val2:
        return 1
    elif val1 == val2:
        return 0
    else:
        return -1


# ============================================================================


def process_file(infile=None):
    """Prompts the user for a filename (or optionally takes one as a
    paramater). If it is succesfully opened, the file is slurped into a list,
    stripped of newlines, converted to uppercase only, and returned. On
    failure, the user is prompted again for either another filename, or given
    the option to terminate the program.
    """
    if (infile == '-') or (not sys.stdin.isatty()):
        from os.path import exists
        if exists("/dev/tty"):
            return get_stdin()
        else:
            print("Cannot process stdin on this system. Exiting.")
            sys.exit(5)
    elif infile is None:
        infile = input("Enter filename.\n > ")

    lst = None
    while lst is None:
        try:
            with open(infile, 'r') as fp:
                lst = [i.rstrip().upper() for i in fp]

        except FileNotFoundError:
            print("File '%s' not found." % infile)
            infile = input("Please type another filename or hit enter " +
                           "to quit.\n > ")
            if infile in ('', '\n', '\r\n'):
                sys.exit()

        except BaseException as e:
            print("Unexpected error:", e)
            sys.exit(1)

    return lst


def get_stdin():
    lst = [i.rstrip().upper() for i in sys.stdin]
    sys.stdin.close()
    sys.stdin = open("/dev/tty", 'r')
    return lst


###############################################################################
# Init


# Getopt handling always looks so messy.
def get_options():
    """Process a few commandline options because I'm far too lazy to
    interactively type a filename and the number of cards for every test run.
    """
    kwargs = {}
    options = ["hn:123", ["help", "numcards="]]
    valid_numcards = (1, 2, 3)
    try:
        opts, args = getopt.getopt(sys.argv[1:], *options)
    except getopt.GetoptError as e:
        print(e, '\n')
        show_usage(options)  # Exits
    else:
        for opt, optarg in opts:
            opt = opt.lstrip('-')
            if opt in ('h', "help"):
                show_usage(options)  # Exits
            elif opt in ('n', "numcards"):
                if optarg.isnumeric() and int(optarg) in valid_numcards:
                    kwargs["numcards"] = int(optarg)
                else:
                    print("Value for option %s must be one of %s." %
                          (opt, str(valid_numcards)), file=sys.stderr)
                    sys.exit(1)
            elif opt.isdigit() and int(opt) in valid_numcards:
                kwargs["numcards"] = int(opt)
        if args:
            kwargs["infile"] = args[0]

        return kwargs


def show_usage(options):
    """Obligatory service. I miss heredocs."""
    print("""\
Usage: %s -[%s] --[%s]  <FILE>\n
File should be a valid filename containing formatted deck information.
-h --help           Show this help and exit.
-n --numcards=[N]   Specify number of cards placed on the table in war.
-1 -2 -3            Aliases for -n1 -n2 -n3.
\nValues not specified on the command line can be given interactively."""
          % (sys.argv[0], options[0], ', '.join(options[1])))
    sys.exit()


if __name__ == "__main__":
    try:
        main(**get_options())
    except (EOFError, KeyboardInterrupt) as e:
        print("\n\nGoodbye.")
        sys.exit(3)
